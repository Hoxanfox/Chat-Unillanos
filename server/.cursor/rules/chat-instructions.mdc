---
alwaysApply: true
---

# Instrucciones para el Agente de IA: Servidor Chat-Unillanos  Este documento contiene el "conocimiento tribal" y las directrices para desarrollar el servidor del proyecto.  ---  ## Planos Arquitectónicos: Guiando al Agente a Través del Código Base  Este es un monorepo de Maven que contiene el servidor para la aplicación Chat-Unillanos. La arquitectura está estrictamente dividida en **4 capas**, cada una compuesta por uno o más módulos (`.jar`) con dependencias unidireccionales:  ```mermaid  graph TD      subgraph "Capa de Presentación"          A_Main["Main (.jar)"] --> A_GUI["GUI (.jar)"];      end      subgraph "Capa de Lógica de Negocio"          B_Servicios["Servicios (.jar)"] --> B_Validadores["Validadores (.jar)"];      end      subgraph "Capa de Datos"          C_Repositorios["Repositorios (.jar)"];      end      subgraph "Capa de Infraestructura"          D_Netty["Netty (.jar)"] --> D_Config["Config. (.jar)"];          D_Netty --> D_Logs["Logs (.jar)"];          D_Netty --> D_DTOs["DTOs (.jar)"];      end      A_GUI --> B_Servicios;      B_Servicios --> C_Repositorios;      C_Repositorios --> D_DTOs;      B_Servicios --> D_DTOs;      D_Netty -.-> |usa INTERFAZ| B_Servicios;   ``

**Flujo de una Petición:**

1.  **Netty.jar**: Recibe el DTORequest del cliente. Su ClientRequestHandler **NO** contiene lógica, solo delega la petición a la capa de negocio.
    
2.  **Servicios.jar**: El ActionDispatcherImpl recibe la petición y la enruta al servicio correspondiente (ej. AutenticacionService).
    
3.  **Servicios.jar**: El servicio aplica la lógica de negocio, usa Validadores.jar si es necesario y llama a los métodos del repositorio.
    
4.  **Repositorios.jar**: La implementación del repositorio (ej. UsuarioRepositoryImpl) ejecuta el código JDBC contra la base de datos MySQL y devuelve entidades.
    
5.  **DTOs.jar**: Es la librería común para el intercambio de datos entre todas las capas.
    

**Ubicaciones Clave:**

*   **Punto de Entrada Principal:** Presentacion/Main/src/main/java/com/unillanos/server/ServerApplication.java
    
*   **Lógica de Negocio Principal:** LogicaNegocio/Servicios/src/main/java/com/unillanos/server/service/
    
*   **Acceso a Datos (JDBC):** Datos/Repositorios/src/main/java/com/unillanos/server/repository/impl/
    
*   **Manejo de Red (Netty):** Infraestructura/Netty/src/main/java/com/unillanos/server/netty/
    
*   **Definición de DTOs:** Infraestructura/DTOs/src/main/java/com/unillanos/server/dto/
    
*   **Configuración Central:** Infraestructura/Configuracion/src/main/resources/application.properties
    

Comandos Fundamentales: Construir, Probar y Ejecutar
----------------------------------------------------

**1\. Levantar la Base de Datos (Requisito previo):**Desde la raíz del proyecto (ChatServer/):docker-compose up -d

**2\. Compilar todo el Proyecto:**Desde la raíz del proyecto (ChatServer/):mvn clean install

**3\. Ejecutar el Servidor:**Este es un proyecto Spring Boot con JavaFX. El punto de entrada está en el módulo Main.mvn -pl Presentacion/Main spring-boot:run

**4\. Ejecutar Pruebas (cuando se añadan):**mvn test

Flujo de Trabajo y Directivas de Colaboración (¡Importante!)
------------------------------------------------------------

*   **Desarrollo por Fases:** El desarrollo se realizará de forma incremental, siguiendo las Épicas definidas. **No implementes todas las funcionalidades de una vez.** Espera la instrucción explícita para proceder con la siguiente Épica o Tarea. El objetivo es verificar cada componente de forma aislada.
    
*   **No Generar Documentación Adicional:** **No crees archivos .md explicativos** ni resúmenes de implementación. Toda la documentación necesaria está en este Agent.md y en documentacion\_servidor\_v2.md. Concéntrate exclusivamente en generar el código solicitado.
    
*   **Formato de Mensajes de Commit:** Usar "Conventional Commits". Ejemplo: feat(servicios): implementar lógica de creación de canales o fix(repositorios): corregir query en obtener historial.
    
*   **Lista de Verificación antes de un Commit:**
    
    1.  El código compila sin errores (mvn clean install).
        
    2.  Se respetan las convenciones de estilo y arquitectura.
        
    3.  No se han introducido dependencias cíclicas.
        

Las Reglas del Camino: Imponiendo Convenciones y Patrones
---------------------------------------------------------

**Sí:**

*   **Seguir estrictamente la arquitectura modular.** Una clase en un módulo **NO DEBE** importar una clase de un módulo de una capa superior.
    
*   **Inyección de Dependencias:** Usar siempre la inyección por constructor (@Autowired en el constructor) para los componentes de Spring (@Service, @Repository, @Component).
    
*   **Abstracción:** Las capas superiores deben depender de **interfaces** (ej. IUsuarioRepository), no de implementaciones (UsuarioRepositoryImpl).
    
*   **JDBC Limpio:** Toda la lógica JDBC, Connection, PreparedStatement, ResultSet, debe residir **exclusivamente** en las clases de Datos/Repositorios/src/main/java/com/unillanos/server/repository/impl/.
    
*   **Patrón Observer:** Para notificaciones en tiempo real, el LoggerService y el ConnectionManager actúan como "Sujetos". La GUI y otros componentes son "Observadores".
    
*   **Hilos Virtuales de Java 21:** Para tareas asíncronas o que puedan bloquear (como llamadas de red o acceso a disco), utiliza Executors.newVirtualThreadPerTaskExecutor().
    

**No:**

*   **No colocar lógica de negocio en la capa de Infraestructura.** El ChatServerHandler de Netty debe ser lo más simple posible, delegando todo al ActionDispatcher.
    
*   **No usar JPA/Hibernate.** El acceso a datos es **solo con JDBC puro** y el pool de conexiones HikariCP.
    
*   **No realizar consultas a la BD desde los Servicios.** Los servicios **deben** llamar a los métodos de los repositorios.
    
*   **No mezclar responsabilidades.** Los validadores validan, los repositorios persisten, los servicios orquestan.
    

Seguridad y Acceso
------------------

*   **Variables de Entorno:** Todas las credenciales y datos sensibles (como la contraseña de la BD) están en application.properties. Este archivo **no debe** contener valores de producción si el proyecto fuera real.
    
*   **Permisos:**
    
    *   **Permitido sin preguntar:** Leer y modificar archivos de código fuente, ejecutar comandos de Maven (install, test, spring-boot:run).
        
    *   **Preguntar primero:** Antes de modificar archivos de configuración (pom.xml, application.properties, docker-compose.yml) o de añadir nuevas dependencias.# Instrucciones para el Agente de IA: Servidor Chat-Unillanos  Este documento contiene el "conocimiento tribal" y las directrices para desarrollar el servidor del proyecto.  ---  ## Planos Arquitectónicos: Guiando al Agente a Través del Código Base  Este es un monorepo de Maven que contiene el servidor para la aplicación Chat-Unillanos. La arquitectura está estrictamente dividida en **4 capas**, cada una compuesta por uno o más módulos (`.jar`) con dependencias unidireccionales:  ```mermaid  graph TD      subgraph "Capa de Presentación"          A_Main["Main (.jar)"] --> A_GUI["GUI (.jar)"];      end      subgraph "Capa de Lógica de Negocio"          B_Servicios["Servicios (.jar)"] --> B_Validadores["Validadores (.jar)"];      end      subgraph "Capa de Datos"          C_Repositorios["Repositorios (.jar)"];      end      subgraph "Capa de Infraestructura"          D_Netty["Netty (.jar)"] --> D_Config["Config. (.jar)"];          D_Netty --> D_Logs["Logs (.jar)"];          D_Netty --> D_DTOs["DTOs (.jar)"];      end      A_GUI --> B_Servicios;      B_Servicios --> C_Repositorios;      C_Repositorios --> D_DTOs;      B_Servicios --> D_DTOs;      D_Netty -.-> |usa INTERFAZ| B_Servicios;   ``

**Flujo de una Petición:**

1.  **Netty.jar**: Recibe el DTORequest del cliente. Su ClientRequestHandler **NO** contiene lógica, solo delega la petición a la capa de negocio.
    
2.  **Servicios.jar**: El ActionDispatcherImpl recibe la petición y la enruta al servicio correspondiente (ej. AutenticacionService).
    
3.  **Servicios.jar**: El servicio aplica la lógica de negocio, usa Validadores.jar si es necesario y llama a los métodos del repositorio.
    
4.  **Repositorios.jar**: La implementación del repositorio (ej. UsuarioRepositoryImpl) ejecuta el código JDBC contra la base de datos MySQL y devuelve entidades.
    
5.  **DTOs.jar**: Es la librería común para el intercambio de datos entre todas las capas.
    

**Ubicaciones Clave:**

*   **Punto de Entrada Principal:** Presentacion/Main/src/main/java/com/unillanos/server/ServerApplication.java
    
*   **Lógica de Negocio Principal:** LogicaNegocio/Servicios/src/main/java/com/unillanos/server/service/
    
*   **Acceso a Datos (JDBC):** Datos/Repositorios/src/main/java/com/unillanos/server/repository/impl/
    
*   **Manejo de Red (Netty):** Infraestructura/Netty/src/main/java/com/unillanos/server/netty/
    
*   **Definición de DTOs:** Infraestructura/DTOs/src/main/java/com/unillanos/server/dto/
    
*   **Configuración Central:** Infraestructura/Configuracion/src/main/resources/application.properties
    

Comandos Fundamentales: Construir, Probar y Ejecutar
----------------------------------------------------

**1\. Levantar la Base de Datos (Requisito previo):**Desde la raíz del proyecto (ChatServer/):docker-compose up -d

**2\. Compilar todo el Proyecto:**Desde la raíz del proyecto (ChatServer/):mvn clean install

**3\. Ejecutar el Servidor:**Este es un proyecto Spring Boot con JavaFX. El punto de entrada está en el módulo Main.mvn -pl Presentacion/Main spring-boot:run

**4\. Ejecutar Pruebas (cuando se añadan):**mvn test

Flujo de Trabajo y Directivas de Colaboración (¡Importante!)
------------------------------------------------------------

*   **Desarrollo por Fases:** El desarrollo se realizará de forma incremental, siguiendo las Épicas definidas. **No implementes todas las funcionalidades de una vez.** Espera la instrucción explícita para proceder con la siguiente Épica o Tarea. El objetivo es verificar cada componente de forma aislada.
    
*   **No Generar Documentación Adicional:** **No crees archivos .md explicativos** ni resúmenes de implementación. Toda la documentación necesaria está en este Agent.md y en documentacion\_servidor\_v2.md. Concéntrate exclusivamente en generar el código solicitado.
    
*   **Formato de Mensajes de Commit:** Usar "Conventional Commits". Ejemplo: feat(servicios): implementar lógica de creación de canales o fix(repositorios): corregir query en obtener historial.
    
*   **Lista de Verificación antes de un Commit:**
    
    1.  El código compila sin errores (mvn clean install).
        
    2.  Se respetan las convenciones de estilo y arquitectura.
        
    3.  No se han introducido dependencias cíclicas.
        

Las Reglas del Camino: Imponiendo Convenciones y Patrones
---------------------------------------------------------

**Sí:**

*   **Seguir estrictamente la arquitectura modular.** Una clase en un módulo **NO DEBE** importar una clase de un módulo de una capa superior.
    
*   **Inyección de Dependencias:** Usar siempre la inyección por constructor (@Autowired en el constructor) para los componentes de Spring (@Service, @Repository, @Component).
    
*   **Abstracción:** Las capas superiores deben depender de **interfaces** (ej. IUsuarioRepository), no de implementaciones (UsuarioRepositoryImpl).
    
*   **JDBC Limpio:** Toda la lógica JDBC, Connection, PreparedStatement, ResultSet, debe residir **exclusivamente** en las clases de Datos/Repositorios/src/main/java/com/unillanos/server/repository/impl/.
    
*   **Patrón Observer:** Para notificaciones en tiempo real, el LoggerService y el ConnectionManager actúan como "Sujetos". La GUI y otros componentes son "Observadores".
    
*   **Hilos Virtuales de Java 21:** Para tareas asíncronas o que puedan bloquear (como llamadas de red o acceso a disco), utiliza Executors.newVirtualThreadPerTaskExecutor().
    

**No:**

*   **No colocar lógica de negocio en la capa de Infraestructura.** El ChatServerHandler de Netty debe ser lo más simple posible, delegando todo al ActionDispatcher.
    
*   **No usar JPA/Hibernate.** El acceso a datos es **solo con JDBC puro** y el pool de conexiones HikariCP.
    
*   **No realizar consultas a la BD desde los Servicios.** Los servicios **deben** llamar a los métodos de los repositorios.
    
*   **No mezclar responsabilidades.** Los validadores validan, los repositorios persisten, los servicios orquestan.
    

Seguridad y Acceso
------------------

*   **Variables de Entorno:** Todas las credenciales y datos sensibles (como la contraseña de la BD) están en application.properties. Este archivo **no debe** contener valores de producción si el proyecto fuera real.
    
*   **Permisos:**
    
    *   **Permitido sin preguntar:** Leer y modificar archivos de código fuente, ejecutar comandos de Maven (install, test, spring-boot:run).
        
    *   **Preguntar primero:** Antes de modificar archivos de configuración (pom.xml, application.properties, docker-compose.yml) o de añadir nuevas dependencias.