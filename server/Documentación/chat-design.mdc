---
alwaysApply: true
---

# Documento de Diseño - Servidor Chat-Unillanos

## Overview

El servidor Chat-Unillanos implementa una arquitectura modular de 4 capas con separación estricta de responsabilidades. El sistema utiliza Spring Boot para inyección de dependencias, Netty para comunicación asíncrona TCP/IP, JDBC puro para acceso a datos, y JavaFX para la interfaz de administración. La arquitectura sigue principios SOLID, patrón Repository, y aprovecha los hilos virtuales de Java 21 para concurrencia eficiente.

## Architecture

### Arquitectura de 4 Capas

```
┌─────────────────────────────────────────────────────────────┐
│                  CAPA DE PRESENTACIÓN                        │
│  ┌──────────────┐              ┌──────────────┐            │
│  │  Main.jar    │─────────────▶│   GUI.jar    │            │
│  │ (Entry Point)│              │  (JavaFX)    │            │
│  └──────────────┘              └──────────────┘            │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────────┐
│              CAPA DE LÓGICA DE NEGOCIO                       │
│  ┌──────────────────┐         ┌──────────────────┐         │
│  │  Servicios.jar   │────────▶│ Validadores.jar  │         │
│  │ (Orquestación)   │         │  (Validación)    │         │
│  └──────────────────┘         └──────────────────┘         │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────────┐
│                    CAPA DE DATOS                             │
│              ┌──────────────────────┐                        │
│              │  Repositorios.jar    │                        │
│              │  (JDBC + HikariCP)   │                        │
│              └──────────────────────┘                        │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────────┐
│                CAPA DE INFRAESTRUCTURA                       │
│  ┌─────────┐  ┌─────────┐  ┌──────────┐  ┌──────────┐     │
│  │Netty.jar│  │DTOs.jar │  │Config.jar│  │ Logs.jar │     │
│  │(TCP/IP) │  │(Datos)  │  │(Props)   │  │(Logging) │     │
│  └─────────┘  └─────────┘  └──────────┘  └──────────┘     │
└─────────────────────────────────────────────────────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ MySQL 8.x   │
                  │  (Docker)   │
                  └─────────────┘
```

### Flujo de Petición

1. **Cliente** → Envía DTORequest JSON sobre TCP
2. **Netty.jar** → ClientRequestHandler deserializa y delega
3. **Servicios.jar** → ActionDispatcher enruta a servicio específico
4. **Validadores.jar** → Valida datos de entrada
5. **Repositorios.jar** → Ejecuta operaciones JDBC
6. **MySQL** → Persiste/recupera datos
7. **Servicios.jar** → Construye DTOResponse
8. **Netty.jar** → Serializa y envía respuesta al cliente

### Inversión de Dependencias

El módulo Netty (infraestructura) depende de la **interfaz** `IActionDispatcher` definida en la capa de negocio, no de su implementación. Esto permite que la infraestructura sea independiente de la lógica de negocio.

## Components and Interfaces

### 1. Capa de Presentación

#### Main.jar
- **Responsabilidad**: Punto de entrada de la aplicación, inicialización de Spring Boot
- **Clase Principal**: `ServerApplication.java`
- **Funciones**:
  - Inicializar contexto de Spring
  - Configurar y arrancar servidor Netty
  - Inicializar GUI JavaFX
  - Gestionar ciclo de vida de la aplicación

```java
@SpringBootApplication
public class ServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerApplication.class, args);
        // Inicializar JavaFX en hilo separado
    }
}
```

#### GUI.jar
- **Responsabilidad**: Interfaz de administración del servidor
- **Patrón**: MVC (Model-View-Controller)
- **Componentes**:
  - `DashboardController`: Controlador principal
  - `UserTableView`: Vista de usuarios conectados
  - `LogsView`: Vista de logs del sistema
  - `ServerStatusView`: Estado del servidor
- **Patrón Observer**: La GUI observa eventos del LoggerService y ConnectionManager

### 2. Capa de Lógica de Negocio

#### Servicios.jar

**IActionDispatcher** (Interfaz)
```java
public interface IActionDispatcher {
    DTOResponse dispatch(DTORequest request, ChannelHandlerContext ctx);
}
```

**ActionDispatcherImpl** (Implementación)
- Enruta peticiones según el campo `action` del DTORequest
- Delega a servicios específicos (AutenticacionService, MensajeriaService, etc.)

**Servicios Principales**:

1. **AutenticacionService**
   - `registrarUsuario(DTORegistro): DTOResponse`
   - `autenticarUsuario(DTOLogin): DTOResponse`
   - `actualizarPerfil(DTOActualizarPerfil): DTOResponse`

2. **MensajeriaService**
   - `enviarMensajeDirecto(DTOMensaje): DTOResponse`
   - `enviarMensajeCanal(DTOMensaje): DTOResponse`
   - `obtenerHistorial(DTOHistorial): DTOResponse`

3. **CanalService**
   - `crearCanal(DTOCrearCanal): DTOResponse`
   - `unirseCanal(DTOUnirseCanal): DTOResponse`
   - `listarCanales(DTOListarCanales): DTOResponse`

4. **ArchivoService**
   - `subirArchivo(DTOSubirArchivo): DTOResponse`
   - `descargarArchivo(DTODescargarArchivo): DTOResponse`
   - `verificarDuplicado(String hash): boolean`

5. **ConnectionManager**
   - Mantiene mapa de usuarios conectados: `Map<String, ChannelHandlerContext>`
   - `registrarConexion(String userId, ChannelHandlerContext ctx)`
   - `notificarUsuario(String userId, DTOResponse notification)`
   - `notificarCanal(String canalId, DTOResponse notification)`

#### Validadores.jar

**Validadores Específicos**:
- `EmailValidator`: Valida formato de email
- `PasswordValidator`: Valida fortaleza de contraseña
- `DTOValidator`: Valida campos requeridos en DTOs
- `FileValidator`: Valida tamaño y tipo de archivos

### 3. Capa de Datos

#### Repositorios.jar

**Patrón Repository**: Cada entidad tiene su interfaz y implementación

**IUsuarioRepository** (Interfaz)
```java
public interface IUsuarioRepository {
    Optional<UsuarioEntity> findById(String id);
    Optional<UsuarioEntity> findByEmail(String email);
    UsuarioEntity save(UsuarioEntity usuario);
    void updateEstado(String id, EstadoUsuario estado);
}
```

**UsuarioRepositoryImpl** (Implementación)
- Usa HikariCP para obtener conexiones
- Implementa todas las operaciones JDBC
- Usa PreparedStatement para prevenir SQL injection
- Cierra recursos en bloques finally

**Repositorios Principales**:
1. `UsuarioRepositoryImpl`
2. `CanalRepositoryImpl`
3. `MensajeRepositoryImpl`
4. `ArchivoRepositoryImpl`
5. `LogSistemaRepositoryImpl`

**Mappers**: Convierten ResultSet a entidades
```java
public class UsuarioMapper {
    public static UsuarioEntity mapRow(ResultSet rs) throws SQLException {
        // Mapeo de columnas a objeto
    }
}
```

### 4. Capa de Infraestructura

#### Netty.jar

**NettyServer**
- Configura EventLoopGroup con hilos virtuales
- Inicializa pipeline con handlers

**ClientRequestHandler** (ChannelInboundHandlerAdapter)
```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    String json = (String) msg;
    DTORequest request = gson.fromJson(json, DTORequest.class);
    DTOResponse response = actionDispatcher.dispatch(request, ctx);
    ctx.writeAndFlush(gson.toJson(response) + "\n");
}
```

**Delimitador**: LineBasedFrameDecoder (mensajes terminan en `\n`)

#### DTOs.jar

**DTORequest**
```java
public class DTORequest {
    private String action;
    private Object payload; // DTO específico
}
```

**DTOResponse**
```java
public class DTOResponse {
    private String action;
    private String status; // "success" | "error"
    private String message;
    private Object data;
}
```

**DTOs Específicos**: DTOLogin, DTORegistro, DTOMensaje, DTOCrearCanal, etc.

#### Configuracion.jar

**application.properties**
```properties
# Database
spring.datasource.url=jdbc:mysql://localhost:3306/chat_unillanos
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.hikari.maximum-pool-size=10

# Netty
server.netty.port=8080
server.netty.boss-threads=1
server.netty.worker-threads=4
```

#### Logs.jar

**LoggerService**
- Usa SLF4J con Logback
- Registra eventos en logs_sistema (base de datos)
- Notifica a observadores (GUI) de eventos importantes

## Data Models

### Entidades Principales

**UsuarioEntity**
```java
public class UsuarioEntity {
    private String id; // UUID
    private String nombre;
    private String email;
    private String passwordHash;
    private String photoId;
    private String ipAddress;
    private LocalDateTime fechaRegistro;
    private EstadoUsuario estado; // ONLINE, OFFLINE, AWAY
}
```

**CanalEntity**
```java
public class CanalEntity {
    private String id;
    private String nombre;
    private String descripcion;
    private String creadorId;
    private LocalDateTime fechaCreacion;
    private boolean activo;
}
```

**MensajeEntity**
```java
public class MensajeEntity {
    private Long id;
    private String remitenteId;
    private String destinatarioId; // null si es mensaje de canal
    private String canalId; // null si es mensaje directo
    private TipoMensaje tipo; // DIRECT, CHANNEL
    private String contenido;
    private String fileId;
    private LocalDateTime fechaEnvio;
}
```

**ArchivoEntity**
```java
public class ArchivoEntity {
    private String id;
    private String nombreOriginal;
    private String nombreAlmacenado;
    private String hashSha256;
    private Long tamanoBytes;
    private String usuarioId;
    private LocalDateTime fechaSubida;
}
```

### Relaciones

- Un Usuario puede crear múltiples Canales (1:N)
- Un Usuario puede pertenecer a múltiples Canales (N:M) → tabla `canal_miembros`
- Un Usuario puede enviar múltiples Mensajes (1:N)
- Un Mensaje puede tener un Archivo adjunto (1:1 opcional)
- Un Archivo puede ser subido por un Usuario (N:1)

## Error Handling

### Estrategia de Manejo de Errores

1. **Capa de Infraestructura (Netty)**
   - Captura excepciones de red y serialización
   - Retorna DTOResponse con status "error"
   - Registra error en logs

2. **Capa de Servicios**
   - Captura excepciones de negocio (validación, lógica)
   - Convierte excepciones a mensajes de error descriptivos
   - No expone detalles internos al cliente

3. **Capa de Datos**
   - Captura SQLException
   - Cierra recursos en bloques finally
   - Lanza excepciones personalizadas (RepositoryException)

### Excepciones Personalizadas

```java
public class ValidationException extends RuntimeException {
    private String field;
    private String message;
}

public class RepositoryException extends RuntimeException {
    private String operation;
    private Throwable cause;
}

public class AuthenticationException extends RuntimeException {
    private String reason;
}
```

### Formato de Respuesta de Error

```json
{
  "action": "login",
  "status": "error",
  "message": "Credenciales inválidas",
  "data": null
}
```

## Testing Strategy

### Niveles de Testing

1. **Unit Tests** (JUnit 5 + Mockito)
   - Validadores: Probar reglas de validación
   - Mappers: Probar conversión de ResultSet a entidades
   - Servicios: Probar lógica de negocio con repositorios mockeados

2. **Integration Tests**
   - Repositorios: Probar operaciones JDBC contra base de datos de prueba (Testcontainers)
   - Servicios: Probar flujo completo con base de datos real

3. **End-to-End Tests**
   - Cliente de prueba que se conecta al servidor Netty
   - Probar flujos completos: registro → login → enviar mensaje

### Herramientas

- **JUnit 5**: Framework de testing
- **Mockito**: Mocking de dependencias
- **Testcontainers**: Contenedores Docker para tests de integración
- **AssertJ**: Assertions fluidas

### Cobertura de Tests

- Servicios: >80% cobertura
- Repositorios: >90% cobertura
- Validadores: 100% cobertura

## Patrones de Diseño Utilizados

1. **Repository Pattern**: Abstracción del acceso a datos
2. **Dependency Injection**: Spring Boot con inyección por constructor
3. **Observer Pattern**: GUI observa eventos del sistema
4. **Factory Pattern**: MessageFactory para crear DTOResponse
5. **Strategy Pattern**: Validadores intercambiables
6. **Object Pool Pattern**: HikariCP para conexiones de BD
7. **Singleton Pattern**: ConnectionManager (gestionado por Spring)

## Consideraciones de Concurrencia

### Hilos Virtuales (Java 21)

```java
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
executor.submit(() -> {
    // Tarea asíncrona (ej: enviar notificación)
});
```

### Thread-Safety

- **ConnectionManager**: Usa `ConcurrentHashMap` para mapa de conexiones
- **Repositorios**: Sin estado, thread-safe por diseño
- **Servicios**: Sin estado compartido, thread-safe

### Sincronización

- Operaciones de base de datos usan transacciones JDBC
- Notificaciones a múltiples usuarios se envían en paralelo con hilos virtuales

## Seguridad

### Hashing de Contraseñas

```java
BCrypt.withDefaults().hashToString(12, password.toCharArray());
```

### Prevención de SQL Injection

- Uso exclusivo de PreparedStatement
- Nunca concatenar strings para queries

### Validación de Entrada

- Todos los DTOs se validan antes de procesarse
- Sanitización de datos de usuario

### Logging Seguro

- No registrar contraseñas ni tokens
- Ofuscar información sensible en logs

## Escalabilidad

### Estrategias

1. **Pool de Conexiones**: HikariCP con tamaño configurable
2. **Hilos Virtuales**: Millones de conexiones concurrentes
3. **Netty Asíncrono**: No bloqueante, alta throughput
4. **Índices de BD**: En columnas frecuentemente consultadas (email, canal_id, etc.)

### Métricas a Monitorear

- Número de conexiones activas
- Tiempo de respuesta promedio
- Uso de pool de conexiones
- Throughput de mensajes/segundo
# Documento de Diseño - Servidor Chat-Unillanos

## Overview

El servidor Chat-Unillanos implementa una arquitectura modular de 4 capas con separación estricta de responsabilidades. El sistema utiliza Spring Boot para inyección de dependencias, Netty para comunicación asíncrona TCP/IP, JDBC puro para acceso a datos, y JavaFX para la interfaz de administración. La arquitectura sigue principios SOLID, patrón Repository, y aprovecha los hilos virtuales de Java 21 para concurrencia eficiente.

## Architecture

### Arquitectura de 4 Capas

```
┌─────────────────────────────────────────────────────────────┐
│                  CAPA DE PRESENTACIÓN                        │
│  ┌──────────────┐              ┌──────────────┐            │
│  │  Main.jar    │─────────────▶│   GUI.jar    │            │
│  │ (Entry Point)│              │  (JavaFX)    │            │
│  └──────────────┘              └──────────────┘            │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────────┐
│              CAPA DE LÓGICA DE NEGOCIO                       │
│  ┌──────────────────┐         ┌──────────────────┐         │
│  │  Servicios.jar   │────────▶│ Validadores.jar  │         │
│  │ (Orquestación)   │         │  (Validación)    │         │
│  └──────────────────┘         └──────────────────┘         │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────────┐
│                    CAPA DE DATOS                             │
│              ┌──────────────────────┐                        │
│              │  Repositorios.jar    │                        │
│              │  (JDBC + HikariCP)   │                        │
│              └──────────────────────┘                        │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────────┐
│                CAPA DE INFRAESTRUCTURA                       │
│  ┌─────────┐  ┌─────────┐  ┌──────────┐  ┌──────────┐     │
│  │Netty.jar│  │DTOs.jar │  │Config.jar│  │ Logs.jar │     │
│  │(TCP/IP) │  │(Datos)  │  │(Props)   │  │(Logging) │     │
│  └─────────┘  └─────────┘  └──────────┘  └──────────┘     │
└─────────────────────────────────────────────────────────────┘
                         │
                         ▼
                  ┌─────────────┐
                  │ MySQL 8.x   │
                  │  (Docker)   │
                  └─────────────┘
```

### Flujo de Petición

1. **Cliente** → Envía DTORequest JSON sobre TCP
2. **Netty.jar** → ClientRequestHandler deserializa y delega
3. **Servicios.jar** → ActionDispatcher enruta a servicio específico
4. **Validadores.jar** → Valida datos de entrada
5. **Repositorios.jar** → Ejecuta operaciones JDBC
6. **MySQL** → Persiste/recupera datos
7. **Servicios.jar** → Construye DTOResponse
8. **Netty.jar** → Serializa y envía respuesta al cliente

### Inversión de Dependencias

El módulo Netty (infraestructura) depende de la **interfaz** `IActionDispatcher` definida en la capa de negocio, no de su implementación. Esto permite que la infraestructura sea independiente de la lógica de negocio.

## Components and Interfaces

### 1. Capa de Presentación

#### Main.jar
- **Responsabilidad**: Punto de entrada de la aplicación, inicialización de Spring Boot
- **Clase Principal**: `ServerApplication.java`
- **Funciones**:
  - Inicializar contexto de Spring
  - Configurar y arrancar servidor Netty
  - Inicializar GUI JavaFX
  - Gestionar ciclo de vida de la aplicación

```java
@SpringBootApplication
public class ServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerApplication.class, args);
        // Inicializar JavaFX en hilo separado
    }
}
```

#### GUI.jar
- **Responsabilidad**: Interfaz de administración del servidor
- **Patrón**: MVC (Model-View-Controller)
- **Componentes**:
  - `DashboardController`: Controlador principal
  - `UserTableView`: Vista de usuarios conectados
  - `LogsView`: Vista de logs del sistema
  - `ServerStatusView`: Estado del servidor
- **Patrón Observer**: La GUI observa eventos del LoggerService y ConnectionManager

### 2. Capa de Lógica de Negocio

#### Servicios.jar

**IActionDispatcher** (Interfaz)
```java
public interface IActionDispatcher {
    DTOResponse dispatch(DTORequest request, ChannelHandlerContext ctx);
}
```

**ActionDispatcherImpl** (Implementación)
- Enruta peticiones según el campo `action` del DTORequest
- Delega a servicios específicos (AutenticacionService, MensajeriaService, etc.)

**Servicios Principales**:

1. **AutenticacionService**
   - `registrarUsuario(DTORegistro): DTOResponse`
   - `autenticarUsuario(DTOLogin): DTOResponse`
   - `actualizarPerfil(DTOActualizarPerfil): DTOResponse`

2. **MensajeriaService**
   - `enviarMensajeDirecto(DTOMensaje): DTOResponse`
   - `enviarMensajeCanal(DTOMensaje): DTOResponse`
   - `obtenerHistorial(DTOHistorial): DTOResponse`

3. **CanalService**
   - `crearCanal(DTOCrearCanal): DTOResponse`
   - `unirseCanal(DTOUnirseCanal): DTOResponse`
   - `listarCanales(DTOListarCanales): DTOResponse`

4. **ArchivoService**
   - `subirArchivo(DTOSubirArchivo): DTOResponse`
   - `descargarArchivo(DTODescargarArchivo): DTOResponse`
   - `verificarDuplicado(String hash): boolean`

5. **ConnectionManager**
   - Mantiene mapa de usuarios conectados: `Map<String, ChannelHandlerContext>`
   - `registrarConexion(String userId, ChannelHandlerContext ctx)`
   - `notificarUsuario(String userId, DTOResponse notification)`
   - `notificarCanal(String canalId, DTOResponse notification)`

#### Validadores.jar

**Validadores Específicos**:
- `EmailValidator`: Valida formato de email
- `PasswordValidator`: Valida fortaleza de contraseña
- `DTOValidator`: Valida campos requeridos en DTOs
- `FileValidator`: Valida tamaño y tipo de archivos

### 3. Capa de Datos

#### Repositorios.jar

**Patrón Repository**: Cada entidad tiene su interfaz y implementación

**IUsuarioRepository** (Interfaz)
```java
public interface IUsuarioRepository {
    Optional<UsuarioEntity> findById(String id);
    Optional<UsuarioEntity> findByEmail(String email);
    UsuarioEntity save(UsuarioEntity usuario);
    void updateEstado(String id, EstadoUsuario estado);
}
```

**UsuarioRepositoryImpl** (Implementación)
- Usa HikariCP para obtener conexiones
- Implementa todas las operaciones JDBC
- Usa PreparedStatement para prevenir SQL injection
- Cierra recursos en bloques finally

**Repositorios Principales**:
1. `UsuarioRepositoryImpl`
2. `CanalRepositoryImpl`
3. `MensajeRepositoryImpl`
4. `ArchivoRepositoryImpl`
5. `LogSistemaRepositoryImpl`

**Mappers**: Convierten ResultSet a entidades
```java
public class UsuarioMapper {
    public static UsuarioEntity mapRow(ResultSet rs) throws SQLException {
        // Mapeo de columnas a objeto
    }
}
```

### 4. Capa de Infraestructura

#### Netty.jar

**NettyServer**
- Configura EventLoopGroup con hilos virtuales
- Inicializa pipeline con handlers

**ClientRequestHandler** (ChannelInboundHandlerAdapter)
```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    String json = (String) msg;
    DTORequest request = gson.fromJson(json, DTORequest.class);
    DTOResponse response = actionDispatcher.dispatch(request, ctx);
    ctx.writeAndFlush(gson.toJson(response) + "\n");
}
```

**Delimitador**: LineBasedFrameDecoder (mensajes terminan en `\n`)

#### DTOs.jar

**DTORequest**
```java
public class DTORequest {
    private String action;
    private Object payload; // DTO específico
}
```

**DTOResponse**
```java
public class DTOResponse {
    private String action;
    private String status; // "success" | "error"
    private String message;
    private Object data;
}
```

**DTOs Específicos**: DTOLogin, DTORegistro, DTOMensaje, DTOCrearCanal, etc.

#### Configuracion.jar

**application.properties**
```properties
# Database
spring.datasource.url=jdbc:mysql://localhost:3306/chat_unillanos
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.hikari.maximum-pool-size=10

# Netty
server.netty.port=8080
server.netty.boss-threads=1
server.netty.worker-threads=4
```

#### Logs.jar

**LoggerService**
- Usa SLF4J con Logback
- Registra eventos en logs_sistema (base de datos)
- Notifica a observadores (GUI) de eventos importantes

## Data Models

### Entidades Principales

**UsuarioEntity**
```java
public class UsuarioEntity {
    private String id; // UUID
    private String nombre;
    private String email;
    private String passwordHash;
    private String photoId;
    private String ipAddress;
    private LocalDateTime fechaRegistro;
    private EstadoUsuario estado; // ONLINE, OFFLINE, AWAY
}
```

**CanalEntity**
```java
public class CanalEntity {
    private String id;
    private String nombre;
    private String descripcion;
    private String creadorId;
    private LocalDateTime fechaCreacion;
    private boolean activo;
}
```

**MensajeEntity**
```java
public class MensajeEntity {
    private Long id;
    private String remitenteId;
    private String destinatarioId; // null si es mensaje de canal
    private String canalId; // null si es mensaje directo
    private TipoMensaje tipo; // DIRECT, CHANNEL
    private String contenido;
    private String fileId;
    private LocalDateTime fechaEnvio;
}
```

**ArchivoEntity**
```java
public class ArchivoEntity {
    private String id;
    private String nombreOriginal;
    private String nombreAlmacenado;
    private String hashSha256;
    private Long tamanoBytes;
    private String usuarioId;
    private LocalDateTime fechaSubida;
}
```

### Relaciones

- Un Usuario puede crear múltiples Canales (1:N)
- Un Usuario puede pertenecer a múltiples Canales (N:M) → tabla `canal_miembros`
- Un Usuario puede enviar múltiples Mensajes (1:N)
- Un Mensaje puede tener un Archivo adjunto (1:1 opcional)
- Un Archivo puede ser subido por un Usuario (N:1)

## Error Handling

### Estrategia de Manejo de Errores

1. **Capa de Infraestructura (Netty)**
   - Captura excepciones de red y serialización
   - Retorna DTOResponse con status "error"
   - Registra error en logs

2. **Capa de Servicios**
   - Captura excepciones de negocio (validación, lógica)
   - Convierte excepciones a mensajes de error descriptivos
   - No expone detalles internos al cliente

3. **Capa de Datos**
   - Captura SQLException
   - Cierra recursos en bloques finally
   - Lanza excepciones personalizadas (RepositoryException)

### Excepciones Personalizadas

```java
public class ValidationException extends RuntimeException {
    private String field;
    private String message;
}

public class RepositoryException extends RuntimeException {
    private String operation;
    private Throwable cause;
}

public class AuthenticationException extends RuntimeException {
    private String reason;
}
```

### Formato de Respuesta de Error

```json
{
  "action": "login",
  "status": "error",
  "message": "Credenciales inválidas",
  "data": null
}
```

## Testing Strategy

### Niveles de Testing

1. **Unit Tests** (JUnit 5 + Mockito)
   - Validadores: Probar reglas de validación
   - Mappers: Probar conversión de ResultSet a entidades
   - Servicios: Probar lógica de negocio con repositorios mockeados

2. **Integration Tests**
   - Repositorios: Probar operaciones JDBC contra base de datos de prueba (Testcontainers)
   - Servicios: Probar flujo completo con base de datos real

3. **End-to-End Tests**
   - Cliente de prueba que se conecta al servidor Netty
   - Probar flujos completos: registro → login → enviar mensaje

### Herramientas

- **JUnit 5**: Framework de testing
- **Mockito**: Mocking de dependencias
- **Testcontainers**: Contenedores Docker para tests de integración
- **AssertJ**: Assertions fluidas

### Cobertura de Tests

- Servicios: >80% cobertura
- Repositorios: >90% cobertura
- Validadores: 100% cobertura

## Patrones de Diseño Utilizados

1. **Repository Pattern**: Abstracción del acceso a datos
2. **Dependency Injection**: Spring Boot con inyección por constructor
3. **Observer Pattern**: GUI observa eventos del sistema
4. **Factory Pattern**: MessageFactory para crear DTOResponse
5. **Strategy Pattern**: Validadores intercambiables
6. **Object Pool Pattern**: HikariCP para conexiones de BD
7. **Singleton Pattern**: ConnectionManager (gestionado por Spring)

## Consideraciones de Concurrencia

### Hilos Virtuales (Java 21)

```java
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
executor.submit(() -> {
    // Tarea asíncrona (ej: enviar notificación)
});
```

### Thread-Safety

- **ConnectionManager**: Usa `ConcurrentHashMap` para mapa de conexiones
- **Repositorios**: Sin estado, thread-safe por diseño
- **Servicios**: Sin estado compartido, thread-safe

### Sincronización

- Operaciones de base de datos usan transacciones JDBC
- Notificaciones a múltiples usuarios se envían en paralelo con hilos virtuales

## Seguridad

### Hashing de Contraseñas

```java
BCrypt.withDefaults().hashToString(12, password.toCharArray());
```

### Prevención de SQL Injection

- Uso exclusivo de PreparedStatement
- Nunca concatenar strings para queries

### Validación de Entrada

- Todos los DTOs se validan antes de procesarse
- Sanitización de datos de usuario

### Logging Seguro

- No registrar contraseñas ni tokens
- Ofuscar información sensible en logs

## Escalabilidad

### Estrategias

1. **Pool de Conexiones**: HikariCP con tamaño configurable
2. **Hilos Virtuales**: Millones de conexiones concurrentes
3. **Netty Asíncrono**: No bloqueante, alta throughput
4. **Índices de BD**: En columnas frecuentemente consultadas (email, canal_id, etc.)

### Métricas a Monitorear

- Número de conexiones activas
- Tiempo de respuesta promedio
- Uso de pool de conexiones
- Throughput de mensajes/segundo
